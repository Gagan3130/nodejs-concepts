# Why do we need worker threads at all?
A server can quickly become overwhelmed by a CPU-intensive workload. To illustrate, imagine you have two endpoints: one performs a simple, non-CPU intensive task, while the other handles a complex CPU-intensive operation that takes 10 seconds to complete. If your server is occupied with the CPU-intensive request, it won’t be able to promptly respond to the non-CPU-intensive request. This problem arises because we violate the golden rule of NodeJS: i.e. Don’t Block the Event Loop.

In NodeJS the I/O operations are handled separately and when they are finished, the event loop adds the callback associated with the I/O task in a microtask queue. When the call stack in the main thread is clear, the callback is pushed on the call stack and then it executes. To make this clear, the callback associated with the given I/O task does not execute in parallel; however, the task itself of reading a file or a network request happens in parallel with the help of the threads. Once the I/O task finishes, the callback runs in the main thread.

In Worker thread, we will offload a CPU-intensive task to another thread using the worker-threads module to avoid blocking the main thread. To do this, you will create a worker.js file that will contain the CPU-intensive task. In the parent.js file, you will use the worker-threads module to initialize the thread and start the task in the worker.js file to run in parallel to the main thread. Once the task completes, the worker thread will send a message containing the result back to the main thread.
We already know by now that when NodeJS process is launch, it gets launched with One process, One thread, One event loop, One V8 Engine Instance, One Node.js Instance. Just like main thread, each worker will have its own instance of V8, nod, libuv instance and Event Loop within the same process.
A V8 isolate refers to a separate entity within the chrome V8 runtime. It possesses its own JS heap and a microtask queue. This unique setup enables every Node.js worker to execute its JavaScript code in complete isolation from other workers

Each worker is connected to its parent worker via a message channel.
